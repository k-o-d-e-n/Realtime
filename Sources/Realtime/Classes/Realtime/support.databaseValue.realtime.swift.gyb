%{
support_types = ['Bool', 'Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Double', 'Float', 'String', 'Data']
int_convertible_types = ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64']
}%

extension RealtimeDatabaseValue.Dictionary {
    % for type1 in support_types:
        % for type2 in support_types:
        mutating func setValue(_ value: ${type1}, forKey key: ${type2}) {
            properties.append((RealtimeDatabaseValue(key), RealtimeDatabaseValue(value)))
        }
        % end
        mutating func setValue(_ value: RealtimeDatabaseValue, forKey key: ${type1}) {
            properties.append((RealtimeDatabaseValue(key), value))
        }
    % end
}

public extension RealtimeDatabaseValue {
% for type in support_types:
    func typed(as type: ${type}.Type) throws -> ${type} {
        guard case let .${type.lower()}(v) = backend else { throw RealtimeError(source: .coding, description: "Mismatch type") }
        return v
    }
% end
    func typed(as type: Int.Type) throws -> Int {
        switch backend {
        % for type in int_convertible_types:
        case .${type.lower()}(let v): return Int(v)
        % end
        default: throw RealtimeError(source: .coding, description: "Mismatch type")
        }
    }
    func typed(as type: UInt.Type) throws -> UInt {
        switch backend {
        % for type in int_convertible_types:
        case .${type.lower()}(let v): return UInt(v)
        % end
        default: throw RealtimeError(source: .coding, description: "Mismatch type")
        }
    }
}

% for type in support_types:
public extension Representer where V == ${type} {
    static var realtimeDataValue: Representer<${type}> {
        return Representer<${type}>(encoding: RealtimeDatabaseValue.init(_:), decoding: V.init(data:))
    }
}
% end
//public extension Representer where V == Int {
//    static var realtimeDataValue: Representer<Int> {
//        return Representer<Int>(encoding: RealtimeDatabaseValue.init(_:), decoding: V.init)
//    }
//}
//public extension Representer where V == UInt {
//    static var realtimeDataValue: Representer<UInt> {
//        return Representer<UInt>(encoding: RealtimeDatabaseValue.init(_:), decoding: V.init)
//    }
//}

% for type in support_types:
public extension Representer where V: RawRepresentable, V.RawValue == ${type} {
    static var rawRepresentable: Representer<V> {
        return self.default(Representer<V.RawValue>.realtimeDataValue)
    }
}
% end

public extension Transaction {
% for type in support_types:
    func addValue(_ value: ${type}, by node: Node) {
        addValue(RealtimeDatabaseValue(value), by: node)
    }
% end
}

public extension RawRepresentable where Self.RawValue == String {
% for type in support_types:
    func property(in obj: Object) -> Property<${type}> {
        return property(in: obj, representer: .realtimeDataValue)
    }
    func property(in obj: Object) -> Property<${type}?> {
        return property(in: obj, representer: .realtimeDataValue)
    }
% end
//    func property(in obj: Object) -> Property<Int> {
//        return property(in: obj, representer: .realtimeDataValue)
//    }
//    func property(in obj: Object) -> Property<Int?> {
//        return property(in: obj, representer: .realtimeDataValue)
//    }
//    func property(in obj: Object) -> Property<UInt> {
//        return property(in: obj, representer: .realtimeDataValue)
//    }
//    func property(in obj: Object) -> Property<UInt?> {
//        return property(in: obj, representer: .realtimeDataValue)
//    }
}
